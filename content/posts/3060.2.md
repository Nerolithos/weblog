---
title: "💻 CSC3060 Week 3-4 More about Computer System Fundamentals"
date: 2026-01-20T10:30:34+08:00
draft: false
summary: "CUHKSZ 大二课程 CSC3060 的 Week 1~2，引入计算机系统中软硬件————各种数据类型的运算"
categories: 
- SDS
tags: 
- CSC3060
featured_image: "/images/30602.jpg"
---



# Week 3  Process of Data

## 整数运算 (Integer Arithmetics)

由于 C 语言家族的时代和奠基性，其数据类型不是 Python 那样动态存储的，由于运算 “溢出” 导致的严重问题层出不穷。

⚠️ n-bit **有符号数**的溢出：**"wraparound"**——$u = (a + b)\bmod 2^n \quad$

- **上溢**：超过上界就减去 2<sup>n</sup>，绕到负区间
- **下溢**：低于下界就加上 2<sup>n</sup>，绕到正区间

2 补码数溢出的检测：

```cpp
int32_t sign(int32_t x) {
    return (uint32_t)x >> 31;
}
bool add_overFlow(int32_t a, int32_t b, int32_t r) {
    return ((~(sign(a) ^ sign(b))) & (sign(a) ^ sign(r))) != 0;
}
```

不会在硬件层面上用 trap 捕捉溢出 (比如用 CPU 逻辑门限制)，否则会产生巨大的效率损失，而且有些领域 (如哈希加密) 需要用到溢出 —— 故一般用软件处理。

精确异常：由于计算机执行指令有可能乱序执行，部分较快的运算会先完成 —— 快指令先把结果写进寄存器，一旦前面某条慢指令异常，状态就会乱。为了乱序执行下仍满足 “Precise Exception”，CPU 必须做很多额外的复杂机制：**机器内部可以乱跑，但对外必须 “看起来” 是顺序的。**

</br>

</br>

## 硬件角度看运算

### 1-bit 全加器和加减法

加法进位有两个构成：propagate (传递进位) 和 generate (产生进位)

对于两个二进制数 A 和 B，其某一位 i 受到上一位 i-1 的进位 C<sub>in</sub> ，其加法结果是：S<sub>i</sub> = A<sub>i</sub> ^ B<sub>i</sub> ^ C<sub>in</sub>

当前位是否产生进位：C<sub>out</sub> = (A<sub>i</sub> & B<sub>i</sub>) | (C<sub>in</sub> & (A<sub>i</sub> ^ B<sub>i</sub>))



![](https://i.postimg.cc/VkcJRzzV/jie-ping2026-01-20-10-37-42.png)

具体的 cpp 实现方法——利用位移运算 **CLA**：

```cpp
static uint32_t add(uint32_t a, int32_t b) {
    uint32_t p = a ^ b;
    int32_t g = a & b;
  
    g = g | (p & (g << 1));
    p = p & (p << 1); 
    // carry look-ahead: 重复翻倍检测进位 <<1, <<2, <<4 ... 直到覆盖位宽
    return (a ^ b) ^ (g << 1);
}
```

类似的，减法很容易实现，因为 A - B 等价于 A + (~B+1)。

</br>

### 乘法器

类似于十进制数乘法，两个数相乘等于 “第一个数乘上第二个数的各位及其维权的和”。在二进制 无符号数中，这相当于：$a \times m = \sum_{i=0}^{n} m_i (a << i)$，类似于小学生做乘法每乘一位往左移一次，我们也用左移表示 “增加位权”。

```pseudocode
       0010       A  
     × 1011       B            C = 0u
-------------------------------------- "Shift and Add Method"
       0010   if(B & 1u) C += (A << 0)
      0010    if(B & 2u) C += (A << 1)
     0000     if(B & 4u) C += (A << 2)
    0010      if(B & 8u) C += (A << 3)
--------------------------------------
 = 00010110       C
```

至于有符号整数，我们只关心结果的符号等于 A ^ B 即可。

</br>

### 除法器

小学生式做二进制除法的本质是 ：从被除数最高位开始取位，尝试能不能减除数，能减就把新取的那位在商中记作 1，减去除数后继续尝试……

具体逻辑：利用一个掩码 1u<<31，循环把它逻辑右移一位，通过 AND 操作可以逐位取出被除数，并存到一个临时变量中（左移一位并添加到最低位），每取一位把这个变量减一次除数，若结果不是负数，就往 ”商“ 加上当前的掩码。

</br>

</br>

*T.B.C*










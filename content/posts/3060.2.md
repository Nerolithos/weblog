---
title: "💻 CSC3060 Week 3-4 More about Computer System Fundamentals"
date: 2026-01-20T10:30:34+08:00
draft: false
summary: "CUHKSZ 大二课程 CSC3060 的 Week 1~2，引入计算机系统中软硬件————各种数据类型的运算"
categories: 
- SDS
tags: 
- CSC3060
featured_image: "/images/30602.jpg"
---



# Week 3  Process of Data

## 整数运算 (Integer Arithmetics)

由于 C 语言家族的时代和奠基性，其数据类型不是 Python 那样动态存储的，由于运算 “溢出” 导致的严重问题层出不穷。

⚠️ n-bit **有符号数**的溢出：**"wraparound"**——$u = (a + b)\bmod 2^n \quad$

- **上溢**：超过上界就减去 2<sup>n</sup>，绕到负区间
- **下溢**：低于下界就加上 2<sup>n</sup>，绕到正区间

2 补码数溢出的检测：

```cpp
int32_t sign(int32_t x) {
    return (uint32_t)x >> 31;
}
bool add_overFlow(int32_t a, int32_t b, int32_t r) {
    return ((~(sign(a) ^ sign(b))) & (sign(a) ^ sign(r))) != 0;
}
```

不会在硬件层面上用 trap 捕捉溢出 (比如用 CPU 逻辑门限制)，否则会产生巨大的效率损失，而且有些领域 (如哈希加密) 需要用到溢出 —— 故一般用软件处理。

精确异常：由于计算机执行指令有可能乱序执行，部分较快的运算会先完成 —— 快指令先把结果写进寄存器，一旦前面某条慢指令异常，状态就会乱。为了乱序执行下仍满足 “Precise Exception”，CPU 必须做很多额外的复杂机制：**机器内部可以乱跑，但对外必须 “看起来” 是顺序的。**

</br>

### 1-bit 全加器和加减法

加法进位有两个构成：propagate (传递进位) 和 generate (产生进位)

对于两个二进制数 A 和 B，其某一位 i 受到上一位 i-1 的进位 C<sub>in</sub> ，其加法结果是：S<sub>i</sub> = A<sub>i</sub> ^ B<sub>i</sub> ^ C<sub>in</sub>

当前位是否产生进位：C<sub>out</sub> = (A<sub>i</sub> & B<sub>i</sub>) | (C<sub>in</sub> & (A<sub>i</sub> ^ B<sub>i</sub>))



![](https://i.postimg.cc/VkcJRzzV/jie-ping2026-01-20-10-37-42.png)

具体的 cpp 实现方法——利用位移运算 **CLA**：

```cpp
static uint32_t add(uint32_t a, int32_t b) {
    uint32_t p = a ^ b;
    int32_t g = a & b;
  
    g = g | (p & (g << 1));
    p = p & (p << 1); 
    // carry look-ahead: 重复翻倍检测进位 <<1, <<2, <<4 ... 直到覆盖位宽
    return (a ^ b) ^ (g << 1);
}
```

类似的，减法很容易实现，因为 A - B 等价于 A + (~B+1)。

</br>

### 乘法器

类似于十进制数乘法，两个数相乘等于 “第一个数乘上第二个数的各位及其维权的和”。在二进制 无符号数中，这相当于：$a \times m = \sum_{i=0}^{n} m_i (a << i)$，类似于小学生做乘法每乘一位往左移一次，我们也用左移表示 “增加位权”。

```pseudocode
       0010       A  
     × 1011       B            C = 0u
-------------------------------------- "Shift and Add Method"
       0010   if(B & 1u) C += (A << 0)
      0010    if(B & 2u) C += (A << 1)
     0000     if(B & 4u) C += (A << 2)
    0010      if(B & 8u) C += (A << 3)
--------------------------------------
 = 00010110       C
```

至于有符号整数，我们只关心结果的符号等于 A ^ B 即可。

</br>

### 除法器

小学生式做二进制除法的本质是 ：从被除数最高位开始取位，尝试能不能减除数，能减就把新取的那位在商中记作 1，减去除数后继续尝试……

具体逻辑：利用一个掩码 1u<<31，循环把它逻辑右移一位，通过 AND 操作可以逐位取出被除数，并存到一个临时变量中（左移一位并添加到最低位），每取一位把这个变量减一次除数，若结果不是负数，就往 ”商“ 加上当前的掩码。

</br>

</br>

## 浮点数和浮点数运算

相比整数，浮点数是对数字 ”不精确的估计“。复习之前提到的 IEEE 的单/双精度浮点数表达：

| type   | sizeof(～) | composition                         | composition size |
| ------ | ---------- | ----------------------------------- | :--------------- |
| float  | 4 Byte     | sign, exponent + **127**, fraction  | 1b + 8b + 23b    |
| double | 8 Byte     | sign, exponent + **1023**, fraction | 1b + 11b + 52b   |

⚠️ Bias (指数偏移量)：为了表示负指数，我们将指数加上 **2<sup>小数位宽-1</sup>-1**。

以单精度数为例，有两种指数情况：

- 若 e ≠ 0000...0 或 1111...1 (**规格化 normaliaed**)：$$x = (-1)^s \times (1+\frac{f}{2^{23}})\times 2^{(e-127)}\ \ (s:sign, f:fraction, e:exponent)$$
- 若 e = 00000000 (**非规格化 denormalized**)，当 f = 0 时表示 0：$$x = (-1)^s \times \left(\frac{f}{2^{23}}\right)\times 2^{-126}$$
- 若 e = 11111111 (**非规格化 denormalized**)：$$F=0: \pm\infty,\ \ F ≠ 0: NaN$$

⚠️ 注意：在 denormalized 情况下，指数**恒为 +126，不存在 ”偏离量 +127“**，比如 “0 00000000 1000...” 就是 2<sup>-126</sup>x(2<sup>22</sup>/2<sup>23</sup>) = 2<sup>-127</sup>。

</br>

### 何为浮点数？

⚠️ 核心：<u>表达范围与精确性不可兼得</u>！根据**等比例缩放**，巨大数的精确性不如 0 附近的小数重要。

“denormalized” 区段的意义：<u>将 -127 这个最小指数直接借给部分 -1 到 1 之间的极小数</u>。从 2<sup>-149</sup> (smallest denormalized) 到 2<sup>-126</sup> (smallest normalized) 之间人为制造出有一段稠密的可表示数，间隔是固定的。如此，实现**渐进下溢**：小正数在 rounding 时一步步接近 0，而不是断崖式被下溢到 0。(在乘除法中，0 和  2<sup>-149</sup> 有很大区别)

![](https://i.postimg.cc/GhP0mTqh/jie-ping2026-01-22-11-16-21.png)

如此，我们牺牲了大数的精度，只在接近 0 的地方精确 (如上图)。<u>这种 ”可精确表达点的浮动“ 换来更大的表达范围</u>，故得名 ”浮点数“。

</br>

### 二进制展开

我们通过将一个十进制数的小数部分循环反复 ”乘二并取 1 的余“可以得到转化为二进制浮点数：![](https://i.postimg.cc/15DgRBkm/jie-ping2026-01-22-11-30-10.png)

- 标准二进制展开法：1、分离整数小数部分；2、小数部分循环进行 x 2 并 mod 1，直到找出规律

</br>

### Rounding (近似)

IEEE 有四种 rounding 模式: **Round-to-even**, Round-towards-0, Round down, Round up。最常用的默认方法是偶数近似。浮点数强转换到整数时则会用 Round-towards-0。

</br>

### 浮点数运算

- 加法/乘法交换律存在，但结合律不存在：(2 + 2<sup>100</sup>) - 2<sup>100</sup> ≠ 2 + (2<sup>100</sup> - 2<sup>100</sup>)  左侧估计右侧精确。
- int32_t 强转换 float 是精确的，反之很可能发生近似，因为 float 的表达范围比 int32_t 大，甚至可能溢出。

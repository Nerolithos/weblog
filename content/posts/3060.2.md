---
title: "💻 CSC3060 Week 3-4 More about Computer System Fundamentals"
date: 2026-01-20T10:30:34+08:00
draft: false
summary: "CUHKSZ 大二课程 CSC3060 的 Week 1~2，引入计算机系统中软硬件————各种数据类型的运算"
categories: 
- SDS
tags: 
- CSC3060
featured_image: "/images/30602.jpg"
---



# Week 3  Process of Data

## 整数运算 (Integer Arithmetics)

由于 C 语言家族的时代和奠基性，其数据类型不是 Python 那样动态存储的，由于运算 “溢出” 导致的严重问题层出不穷。

⚠️ n-bit **有符号数**的溢出：**"wraparound"**——$u = (a + b)\bmod 2^n \quad$

- **上溢**：超过上界就减去 2<sup>n</sup>，绕到负区间
- **下溢**：低于下界就加上 2<sup>n</sup>，绕到正区间

2 补码数溢出的检测：

```cpp
int32_t sign(int32_t x) {
    return (uint32_t)x >> 31;
}
bool add_overFlow(int32_t a, int32_t b, int32_t r) {
    return ((~(sign(a) ^ sign(b))) & (sign(a) ^ sign(r))) != 0;
}
```

不会在硬件层面上用 trap 捕捉溢出 (比如用 CPU 逻辑门限制)，否则会产生巨大的效率损失，而且有些领域 (如哈希加密) 需要用到溢出 —— 故一般用软件处理。

精确异常：由于计算机执行指令有可能乱序执行，部分较快的运算会先完成 —— 快指令先把结果写进寄存器，一旦前面某条慢指令异常，状态就会乱。为了乱序执行下仍满足 “Precise Exception”，CPU 必须做很多额外的复杂机制：**机器内部可以乱跑，但对外必须 “看起来” 是顺序的。**

</br>

### 1-bit 全加器和加减法

加法进位有两个构成：propagate (传递进位) 和 generate (产生进位)

对于两个二进制数 A 和 B，其某一位 i 受到上一位 i-1 的进位 C<sub>in</sub> ，其加法结果是：S<sub>i</sub> = A<sub>i</sub> ^ B<sub>i</sub> ^ C<sub>in</sub>

当前位是否产生进位：C<sub>out</sub> = (A<sub>i</sub> & B<sub>i</sub>) | (C<sub>in</sub> & (A<sub>i</sub> ^ B<sub>i</sub>))



![](https://i.postimg.cc/VkcJRzzV/jie-ping2026-01-20-10-37-42.png)

具体的 cpp 实现方法——利用位移运算 **CLA**：

```cpp
static uint32_t add(uint32_t a, int32_t b) {
    uint32_t p = a ^ b;
    int32_t g = a & b;
  
    g = g | (p & (g << 1));
    p = p & (p << 1); 
    // carry look-ahead: 重复翻倍检测进位 <<1, <<2, <<4 ... 直到覆盖位宽
    return (a ^ b) ^ (g << 1);
}
```

类似的，减法很容易实现，因为 A - B 等价于 A + (~B+1)。

</br>

### 乘法器

类似于十进制数乘法，两个数相乘等于 “第一个数乘上第二个数的各位及其维权的和”。在二进制 无符号数中，这相当于：$a \times m = \sum_{i=0}^{n} m_i (a << i)$，类似于小学生做乘法每乘一位往左移一次，我们也用左移表示 “增加位权”。

```pseudocode
       0010       A  
     × 1011       B            C = 0u
-------------------------------------- "Shift and Add Method"
       0010   if(B & 1u) C += (A << 0)
      0010    if(B & 2u) C += (A << 1)
     0000     if(B & 4u) C += (A << 2)
    0010      if(B & 8u) C += (A << 3)
--------------------------------------
 = 00010110       C
```

至于有符号整数，我们只关心结果的符号等于 A ^ B 即可。

</br>

### 除法器

小学生式做二进制除法的本质是 ：从被除数最高位开始取位，尝试能不能减除数，能减就把新取的那位在商中记作 1，减去除数后继续尝试……

具体逻辑：利用一个掩码 1u<<31，循环把它逻辑右移一位，通过 AND 操作可以逐位取出被除数，并存到一个临时变量中（左移一位并添加到最低位），每取一位把这个变量减一次除数，若结果不是负数，就往 ”商“ 加上当前的掩码。

</br>

</br>

## 浮点数和浮点数运算

相比整数，浮点数是对数字 ”不精确的估计“。复习之前提到的 IEEE 的单/双精度浮点数表达：

| type   | sizeof(～) | composition                         | composition size |
| ------ | ---------- | ----------------------------------- | :--------------- |
| float  | 4 Byte     | sign, exponent + **127**, fraction  | 1b + 8b + 23b    |
| double | 8 Byte     | sign, exponent + **1023**, fraction | 1b + 11b + 52b   |

⚠️ Bias (指数偏移量)：为了表示负指数，我们将指数加上 **2<sup>小数位宽-1</sup>-1**。

以单精度数为例，有两种指数情况：

- 若 e ≠ 0000...0 或 1111...1 (**规格化 normaliaed**)：$$x = (-1)^s \times (1+\frac{f}{2^{23}})\times 2^{(e-127)}\ \ (s:sign, f:fraction, e:exponent)$$
- 若 e = 00000000 (**非规格化 denormalized**)，当 f = 0 时表示 0：$$x = (-1)^s \times \left(\frac{f}{2^{23}}\right)\times 2^{-126}$$
- 若 e = 11111111 (**非规格化 denormalized**)：$$F=0: \pm\infty,\ \ F ≠ 0: NaN$$

⚠️ 注意：在 denormalized 情况下，指数**恒为 +126，不存在 ”偏离量 +127“**，比如 “0 00000000 1000...” 就是 2<sup>-126</sup>x(2<sup>22</sup>/2<sup>23</sup>) = 2<sup>-127</sup>。

</br>

### 何为浮点数？

⚠️ 核心：<u>表达范围与精确性不可兼得</u>！根据**等比例缩放**，巨大数的精确性不如 0 附近的小数重要。⚠️ **具体的，规格化单精度浮点数在每个 2<sup>e</sup>~2<sup>e+1</sup>区间上间隔 (步长) 为 2<sup>e-23</sup> (e ≥ -126)；非规格化步长固定为 2<sup>-149</sup>。**

非规格化区段的意义：<u>将 -127 这个最小指数直接借给部分 -1 到 1 之间的极小数</u>。从 2<sup>-149</sup> (smallest denormalized) 到 2<sup>-126</sup> (smallest normalized) 之间人为制造出有一段稠密的可表示数，间隔固定。如此，实现**渐进下溢**：小正数在 rounding 时一步步接近 0，而不是断崖式被下溢到 0。(在乘除法中，0 和  2<sup>-149</sup> 有很大区别)

![](https://i.postimg.cc/GhP0mTqh/jie-ping2026-01-22-11-16-21.png)

如此，我们牺牲了大数的精度，只在接近 0 的地方精确 (如上图)。<u>这种 ”可精确表达点的浮动“ 换来更大的表达范围</u>，故得名 ”浮点数“。

</br>

### 二进制展开

我们通过将一个十进制数的小数部分循环反复 ”乘二并取 1 的余“可以得到转化为二进制浮点数：![](https://i.postimg.cc/15DgRBkm/jie-ping2026-01-22-11-30-10.png)

- 标准二进制展开法：1、分离整数小数部分；2、小数部分循环进行 x 2 并 mod 1，直到找出规律

</br>

### Rounding (近似)

IEEE 有四种 rounding 模式: **Round-to-even**, Round-towards-0, Round down, Round up。最常用的默认方法是偶数近似。浮点数强转换到整数时则会用 Round-towards-0，即，**大于 2<sup>24</sup> 时整数不再全部有精确表示**，这时强转换会导致下溢。

</br>

### 浮点数运算

- 加法/乘法交换律存在，但结合律不存在：(2 + 2<sup>100</sup>) - 2<sup>100</sup> ≠ 2 + (2<sup>100</sup> - 2<sup>100</sup>)  左侧估计右侧精确。
- int32_t 强转换 float 是精确的，反之很可能发生近似，因为 float 的表达范围比 int32_t 大，甚至可能溢出。
- FPA：align (对齐指数), add (小数相加), normalize (移到小数的整数位为 1), round&renormalize (处理精度溢出，可能需要重新调整)

</br>

</br>

</br>

# Week 4  Machine-level Programming

## 通过汇编看机器级语言

- **x86** 是一大类源自 Intel 8086 的 **CPUISA家族**。我们以 **x86-64** (AMD64) 为例，是 x86 的 64-bit 扩展。前者指代寄存器为 %eax, %ebx...；后者为 **%rax, %rbx**...。PC 的地址是 **%rip**，命令被移到 PC 就会被执行。
- **ISA** (指令集架构) 是“<u>软件看到的 CPU 规格说明书</u>”。不同 CPU 生态，不同 ISA —— e.g. 复杂的 **CISC** (x86) vs 精简的 **RISC** (ARM、RISC-V)。
- **机器真正执行的是“字节序列”**——十六进制字节，每一段对应一条指令；meanwhile 机器对源码 (变量名、数据类型等) 几乎一无所知。
- **汇编语言**就是某个 ISA 中机器级程序的的人类可读写法。查看机器码常用两条路：
    1. 编译时强制输出汇编文件：`gcc -Og -S xxx.c`
    2. 用 **反汇编器** 把字节序列 “翻译” 得<u>类似于</u>汇编：`objdump -d xxx.o` (Linux)
- 反汇编输出通常含：**地址/偏移、字节、等价汇编**。
- x86-64 的一个重要特性：**指令长度可变 (1–15 字节)**，常用/操作数少的更短。
- 反汇编是“从字节推回指令”，**不需要源代码**；而且反汇编器在指令命名、后缀省略上可能与 GCC 输出略有差别。

</br>

</br>

## x86-64

### 访问信息——寄存器

64 位 CPU 有 1 个指令寄存器 PC (%rip) 和 16 个通用寄存器(%rax, %rbx...)。每个通用寄存器有灵活的用途，最特殊的是 **%rsp** 固定为栈指针。
- 16 个寄存器都属于 64 位整数寄存器，即，来存储整数数据和指针。
- 多少 bit 的 CPU 其寄存器就是对应 bit 的。可以通过 b, w, l, q 控制一次访问 8、16、32 还是 64 位，下文会展开说明。
![](https://i.postimg.cc/VNWTjZZw/jie-ping2026-01-26-21-42-57.png)

</br>

### x86-64 常见汇编指令

1) **数据搬运 / 地址**

- `mov a, b`：**从 a 拷贝数据到 b**，<u>根据传递数据的位宽</u>分为 `movb` = 8b, `movw` = 16b, `movl` = 32b, `movq` = 64b (比如 64 位机器的地址/指针/栈都是 q，所有机器中整数是 l)。这四种后缀在类似命令，如 `call`, `ret`, `pop` 等也适用，实际中经常省略。
![](https://i.postimg.cc/FRcQ0K4k/jie-ping2026-01-26-21-26-09.png)
- `lea`：**取地址/做地址计算**（常用于指针运算、乘加组合，比 mov 不同，它不读内存）

2) **栈**

- `pushq a`：把栈顶指针往 “更低虚拟地址” 拓宽 8B，即 **%rsp -= 8**，然后把 a 的值压栈。
- `popq a`：从栈顶取出到 a (寄存器/内存)，即 **%rsp += 8**。

3) **算术**

- `add` / `sub` / `neg`：加 / 减 / 取反。
- `imul`：乘 (有多种形式)；`idiv`：除 (配合 rdx:rax 作为被除数)。
- `inc` / `dec`：+1 / -1（常被 `add/sub $1` 替代）。
- `and` /` or` / `xor` / `not`：与 / 或 / 异或 / 非。
- `shl` / `shr`：逻辑左移/逻辑右移；`sar`：算术右移 (有符号)。

4) **函数调用**

- `call a`：把返回地址 (下一个指令) **push** 入栈，然后跳到目标执行，即 **mov a, %rip**。
- `ret`：从栈弹出返回地址并跳回去，即 **movq %rsp, %rip**,  **%rsp += 8**。

</br>

### x86-64 操作数与寻址

**操作数 (operand) 三大类:**

- **立即数**：常量，在 AT&T 语法中用 $ 引导 (比如 $1, $0x42)。
- **寄存器**：如 %rax、%rbx 等。
- **内存引用**：用“地址表达式”算出有效地址，再访问该地址处的内存。

**内存寻址格式：Imm(r<sub>b</sub>, r<sub>i</sub>, s)**

- 有效地址由四部分组成：位移 Imm、基址寄存器 r<sub>b</sub>、变址寄存器 r<sub>i</sub>、伸缩因子 s。
- 计算为： **M\[Imm + R\[R<sub>b</sub>] + R\[r<sub>i</sub>]·s]**。其中 R 表示寄存器数组中对应的指，M 表示内存数组中对应的值。
- **伸缩因子** **s** **必须是 1/2/4/8**，这正好覆盖了常见基本类型大小，方便“数组下标 × 元素大小”的地址计算。
- 一些例子：$0x42 的寻址结果是 0x42，0x42 结果是这个内存位置对应的数据，%rax 是这个寄存器中的值，(%rax) 是寄存器值指向内存位置对应的数据。

</br>

</br>

## RISC-V














---
title: "💻 CSC3060 Week 5 Continuation of Machine Level Programming"
date: 2026-02-03T20:37:34+08:00
draft: false
summary: "CUHKSZ 大二课程 CSC3060 的 Week 5，继续探索机器级代码———调用约定和寄存器"
categories: 
- SDS
tags: 
- CSC3060
featured_image: "/images/30603.jpg"
---



其它学生：学者引用文献需要遵守 APA/MPA/Chicago 等引用格式，否则会爽吃 Fail。

SDS 学生：计算机调用需要根据 Calling Convention，不然你们写论文的计算机爽吃 UB 原地升天，~~你们签名承诺不用但还是偷偷用的互联网大模型爽吃 504 Error~~。

</br>

# Week 5  Calling convention and Its Registers

## 调用的约定

#### 在机器的宏观视角下，函数/过程调用的流水线：

从调用方 (Caller) 开始...

1. **准备参数**（寄存器不够/需要按约定放栈时就放栈上）
2. **保存返回地址**（ret）
3. **跳转到被调函数**

工作移交到被调用方 (Callee)...

4. **建立栈帧 (Stack frame)**：栈指针下移，<u>给调用方的栈帧/局部变量/保存寄存器留空间</u>（sp -= stackFrame）

5. **保存需要保存的寄存器**

6. **执行函数主体**

7. **准备返回值**（可能放寄存器 a0/a1，也可能放栈）

8. **恢复保存的寄存器 **并 **返回调用方位置**

- ⚠️ **“栈帧”** 是栈上分配给函数的私有区域，每个函数有自己独立的一段帧 (向下分配)；**"帧指针 fp"** 是函数栈帧的寻址基点，这里用于<u>返回后将栈变回调用前的原样</u>。

#### Meanwhile，栈身上发生了什么？

1. 第 1～3 步 (处于调用方) 时，调用者**建立自己的栈帧**<u>将参数 (如果 a0~a7 放满了) 和返回地址入栈</u>；
2. 第 4～7 步 (处于被调用方) 时，被调用者**建立新栈帧**，<u>将局部变量、要保存的寄存器 (saved regs)、动态对象入栈到这个帧中</u>；
3. 第 8 步 (回到调用方) 后，**被调用者的栈帧被出栈**，栈回到第 1 步之前的样子，fp/sp 指向原先位置。

#### "Saved Regs"

*T.B.C.*


<!DOCTYPE html>
<html lang="zh-cn">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>💻 CSC3200 Final Revision C&#43;&#43; 期末样卷 | Lithos&#39; Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="CUHKSZ 大二课程 CSC3200 是新课，我们用 3002 真卷作复习参考">
    <meta name="generator" content="Hugo 0.134.1">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="http://localhost:1313/ananke/css/main.min.css" >



  
    <link rel="stylesheet" href="http://localhost:1313/css/custom.css">
  

    
    <link rel="stylesheet" href="http://localhost:1313/css/custom.css">
    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/posts/3200.f3/">
    <meta property="og:url" content="http://localhost:1313/posts/3200.f3/">
  <meta property="og:site_name" content="Lithos&#39; Blog">
  <meta property="og:title" content="💻 CSC3200 Final Revision C&#43;&#43; 期末样卷">
  <meta property="og:description" content="CUHKSZ 大二课程 CSC3200 是新课，我们用 3002 真卷作复习参考">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-12-11T07:07:34+08:00">
    <meta property="article:modified_time" content="2025-12-11T07:07:34+08:00">
    <meta property="article:tag" content="CSC3200">

  <meta itemprop="name" content="💻 CSC3200 Final Revision C&#43;&#43; 期末样卷">
  <meta itemprop="description" content="CUHKSZ 大二课程 CSC3200 是新课，我们用 3002 真卷作复习参考">
  <meta itemprop="datePublished" content="2025-12-11T07:07:34+08:00">
  <meta itemprop="dateModified" content="2025-12-11T07:07:34+08:00">
  <meta itemprop="wordCount" content="7622">
  <meta itemprop="keywords" content="CSC3200">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="💻 CSC3200 Final Revision C&#43;&#43; 期末样卷">
  <meta name="twitter:description" content="CUHKSZ 大二课程 CSC3200 是新课，我们用 3002 真卷作复习参考">


    <link rel="stylesheet" href="http://localhost:1313/css/custom.css">

    
    <link rel="stylesheet" href="https://unpkg.com/katex@0.16.4/dist/katex.min.css" crossorigin="anonymous">
    <script src="https://unpkg.com/katex@0.16.4/dist/katex.min.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/katex@0.16.4/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function() {
        if (typeof renderMathInElement === "function") {
          renderMathInElement(document.body, {
            delimiters: [
              {left: "$$", right: "$$", display: true},
              {left: "$", right: "$", display: false}
            ]
          });
        } else {
          console.warn("KaTeX 渲染器未定义！");
        }
      });
    </script>
  </head>

  <body class="ma0 avenir bg-near-white">

    
  

  
  <header class="cover bg-top" style="background-image: url('http://localhost:1313/images/test.jpg');">
    <div class="bg-black-60">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://localhost:1313/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Lithos&#39; Blog
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="https://github.com/Nerolithos" title="">
              💻 GitHub
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="https://www.pixiv.net/users/107379421" title="">
              🎨 Pixiv
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="http://localhost:1313/" title="">
              🏠 Home
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="https://ai.nero-lithos.com" title="">
              🤖 CUHKSZ AI
            </a>
          </li>
          
        </ul>
      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

      <div class="tc-l pv6 ph3 ph4-ns">
        
          <div class="f2 f1-l fw2 white-90 mb0 lh-title">💻 CSC3200 Final Revision C&#43;&#43; 期末样卷</div>
          
        
      </div>
    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
        Posts
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">💻 CSC3200 Final Revision C&#43;&#43; 期末样卷</h1>

      

      
      <time class="f6 mv4 dib tracked" datetime="2025-12-11T07:07:34+08:00">December 11, 2025</time>
      

      
    </header>

    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id="c-final-revision">C++ Final Revision</h1>
<p>CSC 3200 是一节 2025-26 学年的新增学科，不存在往年样卷，但 CSC 3002 也有 C++ 内容（区别是没有数据结构），以下是港中深 3002 这门课 2021 年的期末考卷：</p>
<embed src="http://localhost:1313/pdf/3002Question.pdf" type="application/pdf" width="100%" height="600px" />
<p>以下是答案：</p>
<embed src="http://localhost:1313/pdf/3002Answer.pdf" type="application/pdf" width="100%" height="600px" />
</br>
<h1 id="key-takeaways">Key Takeaways</h1>
<ol>
<li><strong>Pointers, Reference and Array</strong></li>
</ol>
<ul>
<li>声明时的星号：<code>char *p;</code> 或 <code>char* p</code> (你想写多少个空格都没区别) 表示声明右边最近的一个变量为指针，指向左边数据类型的对象。所以，<code>char *p, q;</code> 中 <u>q <strong>不是</strong>指针</u>。<code>char const *p;</code> 和 <code>char *const p;</code> 分别表示 ”指向常量的指针“ 和 ”常指针“，与星号的位置有关——⚠️<u>星号右边形容指针，左边形容指向的对象</u>。</li>
<li>声明时的与号：<code>char &amp;r = o;</code> 表示引用一个存在的变量 o，引用就是给 o 起小名叫 r，修改两者中任意一者，另外一个都随之改变。如果函数传参不用引用（不用指针时），就不会改外面的值；如果函数传回的临时变量属于引用类型，会导致数据被清除。<code>char *&amp;p</code> 表示引用一个指针，反之<u> <code>char &amp;*p</code> <strong>不合法</strong></u>。</li>
<li>作为运算符的星号、与号：<code>*p</code> 表示<strong>解引用</strong>，<code>&amp;v</code> 表示<strong>取引用</strong>，<code>*&amp;v == v</code>，<code>&amp;*p == p</code></li>
<li>自增自减符号：<code>++v</code> 先自增后返回值；<code>v++</code> 先返回值再自增，<u>两者<strong>作为循环的 iterator 时没有区别</strong></u>。核心⚠️：<code>*++p</code> 表示先指向下一位再返回解指针；<code>++*p</code> 表示先解指针再返回值+1；<code>*p++</code> 表示先返回解指针再指向下一位；<code>(*p)++</code> 表示先返回解指针再把值+1。</li>
<li>内存：函数中 <code>char arr1[42];</code> 直接在 <strong>Stack</strong> 上申请内存；<code>auto arr2 = new char[42];</code> 在 <strong>Heap</strong> 上申请内存。<strong>注意⚠️</strong>：<u>new 一定会返回指向 Heap 上对象的<strong>指针</strong></u> (arr2)，且这个<u>指针本身默认存在 Stack 上</u>。前者不用删，后者要手动析构：<code>delete[] arr;</code>。如果在函数/循环/判断体外，直接暴露在类中，<code>char arr[42];</code> 这种声明会产生全局变量，存储在 <strong>Global/Static Area</strong>，在任意位置申请 <code>static char</code> 也会存在这里。</li>
<li>数组：数组对象 <code>char arr[42];</code> 会自动隐式衰退为<strong>指向第一个元素的指针</strong>，所以 <code>*arr</code> (第一个元素) 和 <code>arr+n</code> (第 n 个元素) 都是合法的。<strong>注意⚠️</strong>：<u><code>arr++</code> 是<strong>不合法</strong>的</u>，<strong>数组不等价于指针</strong>。反之，<code>auto ptr = arr;</code> 时，<code>ptr[n]</code> 是合法的访问。</li>
<li>双重数组：<code>char arr[][42]</code> 代表一个元素为 “42 位字符数组” 的数组，只会衰退一层：<code>char (*a)[42]</code>，转变为指向第一个 “42 位字符数组” 的指针。<u>双重数组与双重指针毫无关系</u>，所以不能再衰退了。</li>
</ul>
</br>
</br>
<ol start="2">
<li><strong>Time Complexity</strong></li>
</ol>
<ul>
<li>
<p>三种基础排序：</p>
<p><strong>Selection Sort</strong> 从左每次选第 n 小的元素与第 n 位交换； x 个元素时要比较 x-1 次才能知道最小项，总共 $(n-1)+(n-2)+&hellip;+1+0={n(n-1)\over 2}$ 次比较，稳定在 O(n<sup>2</sup>)。<strong>与有序性无关</strong></p>
<p><strong>Insertion Sort</strong> 从左到右把每个元素左移到左边比自己小为止；类似上面，最多 ${n(n-1)\over 2}$ 次移动，平均/最差 O(n<sup>2</sup>)，当本身有序时只遍历一次最优 O(n)。<strong>越有序越快</strong></p>
<p><strong>Bubble Sort</strong> 从左到右两两交换，一般需要多轮；最多 ${n(n-1)\over 2}$ 次交换，平均/最差 O(n<sup>2</sup>)，当本身有序时如果加检测模块可以做到最优 O(n)。<strong>越有序越快</strong></p>
</li>
<li>
<p>四种二分思路排序：</p>
<p><strong>Quick Sort</strong> 将中点作 pivot 左边放更小元素右边放更大元素，对左右区间递归；n 个元素放在二叉树中高 log<sub>2</sub>n，平均/最优 O(nlogn)，如果每次选择的 pivot 都是最大/最小值，<strong>退化为 Selection Sort</strong>，最差 O(n<sup>2</sup>)。<strong>与有序性无关，但与 pivot 有关</strong></p>
<p><strong>BST Sort</strong> insert 到二叉树中然后中序遍历；同上，最优/平均 O(nlogn)，如果数列本身已经有序会<strong>退化为链表</strong>，最差 O(n<sup>2</sup>)。<strong>越有序越慢</strong></p>
<p><strong>Merge Sort</strong> 递归地左右分组直到只有一个元素，回溯排序；因为不依靠选择中值也没用 BST 结构，不会退化并稳定在 O(nlogn)。 <strong>与有序性无关</strong></p>
<p><strong>Heap Sort</strong> 建最小堆然后进行 n 次 deleteMin；建堆 O(n)，n 次 deleteMin 每次 O(logn)，稳定在 O(nlogn)。<strong>与有序性无关</strong></p>
</li>
<li>
<p>平均情况 Quick Sort ≲ Merge Sort ≲ Heap Sort ≲ BST Sort ≪ Insertion Sort ≲ Bubble Sort ≲ Selection Sort</p>
</li>
</ul>
</br>
</br>
<ol start="3">
<li><strong>OOP</strong></li>
</ol>
<ul>
<li>
<p><u>OOP 的三大核心</u>：<strong>Encapsulation</strong> (将 method 和 data 打包成 class，防止泄露或干扰)；<strong>Polymorphism</strong> (分为 compile-time (overload) 通过不同签名实现函数同名，和 run-time (override) 子类覆盖父类的同名函数)；<strong>Inheritance</strong> (子类继承父类的成员)。</p>
</li>
<li>
<p>重载：函数的参数类型、参数个数都算签名，但 ⚠️<strong>return 类型不算</strong>。</p>
</li>
<li>
<p>继承：<code>class Son : public Father</code> 子类无法访问父类的 protected 字段，之外的字段<strong>降级</strong>为继承类型 (e.g. public inheritance 不变，private inheritance 全变 private) 。</p>
<p><strong>vitual inheritance</strong>： 可以解决 diamond inheritance (A-BC-D 菱形继承) 时 A 的二义性 ambiguity (D 里只生成一份虚拟 A 基类)。</p>
<p><strong>virtual function</strong>：<u>父类中声明 <strong>virtual</strong> 的函数都会调用子类的非 virtual 同名函数</u>，即发生 <strong>run-time polymorphism</strong>，反之未特别声明时，<strong>函数优先调用父类 (⚠️在子类中声明无效)</strong>。</p>
</li>
<li>
<p>完全没有自定义参数的操作符重载是违法的，比如 <code>operator+(char &amp;a, char &amp;b) {}</code> 就无法编译；std::string，以及自定义的 struct、enum 或 class 都可以重载操作符。</p>
</li>
<li>
<p><code>class Example {int a; char* b;};</code> 的 <strong>Constructor</strong> 初始化部分可以简写为 <code>public: Example (int x, char* y) : a(x), b(y) {}</code></p>
</li>
<li>
<p>自定义类时，一般都要把<u><strong>成员变量放在 private 字段</strong></u>，并暴露 constructor、getter、setter 等接口 (interface) 来实现访问。但是，声明一个方法为 <u><code>friend</code> 可以在类外直接用/改 private 内容</u>。注意⚠️：A 类的 private 部分声明<code>friend class B</code>  只是给 B 的成员开了“通行证”，仍不能在类外访问 A 的私有部分！</p>
</li>
<li>
<p>⚠️C++ 默认的拷贝构造函数是 shallow copying <strong>只拷贝值，指针也复制</strong>，导致复制后指向相同内存位置，逻辑类似于<strong>引用</strong>； deep copying 直接 new 一个新位置，不受母本印象。<strong>Rule of Three</strong>：只要定义其中一个，就要全部自定义：Copy Constructor (复制实例)、Copy Assgnment Operator (赋值)、Destructor (析构)。</p>
</li>
<li>
<p>namespace 是一层保护类的空间，通过 <code>using namespace std;</code> 或 <code>using std::string</code> 这类语句防止不同空间中重名函数的混淆。</p>
</li>
</ul>
</br>
</br>
<ol start="4">
<li><strong>Basic Data Structure</strong></li>
</ol>
<ul>
<li>
<p>Collection Class (容器类) 是一种 ADT。一般说数组、动态数组、链表、集合、表都算是经典的容器类，栈和堆是受限的容器。在 STD 中，容器类返回的容量参数 (接口一般叫 <code>.size()</code>) 是 <strong>size_t</strong> 类型的，不转换就不能直接当 int 使用。容器类的 <code>.end()</code> 函数一般返回最后一个元素的<strong>下一个空位</strong>。</p>
</li>
<li>
<p><strong>动态数组</strong> <code>std::vector</code> 是可以自动/手动<strong>扩容</strong>的数组。实例化比如：<code>new std::vector&lt;int&gt; arr(42)</code>。典型的容器类，要求 <u>effective size 永远<strong>小于等于</strong> allocation size</u>，也就是 <code>arr.size() &lt;= arr.capacity()</code>。预留函数 <code>.reserve(x)</code> 扩容 a.s. 到 x，不改变 e.s.，且<strong>无法减小</strong>。扩容函数 <code>.resize(x, v)</code>将 e.s. 扩大到 x，并把未定义的项初始化为 v，<strong>可以减小，但不改变 a.s.</strong>。<code>.push_back()</code> 向数组尾部添加元素。动态数组的<strong>随机插入 O(n)，随机访问O(1)</strong>。</p>
</br>
</li>
<li>
<p><strong>链表 LinkedList</strong> 由节点类 <code>class Node {T value; Node&lt;T&gt;* next;};</code> 以及表体类 <code>class List {List () {}}</code> 构成，每个<strong>旧节点的 next 成员指向新节点</strong>的内存位置。在 List 中常设置一个 private 的<strong>空占位节点</strong>，并在构造函数中初始化 <code>dummyHead = new Node&lt;T&gt;(T(), nullptr);</code>，这样就<strong>不需要每次插/删都检测是否空</strong>。</p>
</br>
<p><code>.insert()</code> 只需要传入<strong>前序节点</strong>的指针 prev，然后 <code>prev-&gt;next = new Node&lt;T&gt;(v, prev-&gt;next);</code> 即可 (新节点接 prev 原本的后节点，然后 prev 接新节点)。<code>.delete()</code> 先 find <strong>前序节点</strong> prev，然后 <code>auto target = prev-&gt;next; prev-&gt;next = prev-&gt;next-&gt;next; delete target;</code> <u>只要有链表结构，绕过被删除项前<strong>一定要做临时指针</strong></u>，否则绕过后想删除时就找不到它了。</p>
<p>链表的所有节点都是 new 产生的，<strong>要逐个析构</strong>。<strong>链表的随机插入 O(1)，随机访问 O(n)</strong>，恰好与 (动态) 数组相反。</p>
</br>
</li>
<li>
<p><strong>栈 Stack</strong> 是 LIFO，<strong>只从一边操作</strong> (top) 的受限数据类型。</p>
<p>接口：push()、pop()、top()、isEmpty()</p>
<p>数组栈：stack[] 数组中，<u>用 top 索引栈顶的<strong>下一位</strong></u>；插 <code>T&amp; pop() {return stack[--top];}</code>；删 <code>void push(const T x) {stack[top++] = x;}</code> ；是否空 <code>bool isEmpty(){return !(top-1);}</code>。</p>
<p>链栈：类似于链表，需要 (Node 和 Stack) 两个类。与链表相反，新元素指向旧元素，从<strong>栈顶逐个指向栈底</strong>，用 topPtr <strong>指向顶节点</strong>；操作与链表相似，不再赘述。</p>
</br>
</li>
<li>
<p><strong>队列 Queue</strong> 是 FIFO，<strong>只从两边操作</strong> (back 进 front 出) 的受限数据类型。</p>
<p>接口：enqueue()、dequeue()、isEmpty()、getFront()</p>
<p>链队列：类似于链表，需要 (Node 和 Queue) 两个类。Queue 中 front 指向队头节点，back 指向队尾节点。与链表一样，旧元素指向新元素，从队头指向队尾。</p>
<p><u>循环数组队列</u>：利用 Circular-Array 首位衔接弥补数组难以整体移动。在<strong>插/删时无需整体移动</strong>同时做到<strong>防止超出索引</strong>。(1) 一种实现方式只能用数组大小 const MAX <strong>-1</strong>，front 索引队首，<u>back 索引<strong>队尾的下一位</strong></u>。⚠️核心：<u>enqueue 时先插入然后后移 back ( <code>back = (back+1)%MAX;</code>)，dequeue 时 <code>front = (front+1)%MAX;</code></u>，用求余把<u><strong>超出索引的位置绕回数组开头</strong></u>。⚠️限制条件：要入队不能满 <code>if(!(back+1)&amp;MAX == front)</code>，要出队不能空  <code>if(front != back)</code>。<strong>永远有一位填不了</strong>，这个代价换来可以简单判断满/空的语句。(2) 另一种实现方式虽可以填满 MAX 位，但是要用一个全局变量来计数 (用填了多少位判断满/空)</p>
</br>
</li>
<li>
<p><strong>映射(字典) Map</strong> 存储 键值对 <code>struct KeyValuePair {T1 key, T2 value};</code>，key 用作索引故不可重复。轻量级的 map 可以用 (动态) 数组实现，用 <code>map[index].key</code> 形式访问键。</p>
<p>哈希表 HashMap：比如 <code>std::unordered_map</code>，利用<strong>哈希函数</strong>将 key 映射到桶数组的索引，即：<code>int BucketIdx = HashFunc(key) % Buckets.size();</code>，良好的哈希函数<strong>尽量避免碰撞</strong> (<u>最好 key 对桶双射</u>)，发生碰撞时用<u>链表或数组将多个 KVP 挂在 Bucketa 数组中</u> (前者用桶数组存 Node，后者将桶数组做成二维数组)。无碰撞时<strong>除遍历全部 O(1)</strong>，KVP 全部碰撞到同个桶时<u>哈希退化为链表，回到 O(n)</u>。为避免退化，检测 <u>KVP 数量与 Buckets 数量的比</u>，过大时要 <strong>rehash</strong> (扩容Buckets 数组并重新计算哈希)。一般要求<u>比例大约低于 <strong>0.7</strong></u>。</p>
</br>
</li>
<li>
<p><strong>集合 Set</strong> 无需不重复的数据集。可用 Hash、BST、链表等实现。</p>
<p>Character Set(<strong>Bitset</strong>)：比如 <code>std::bitset</code> ，<u>用二进制数表示某数据是否属于集合</u>，一般用在连续的小集合上，如 ASCII 集合，0～1000整数集合。<strong>除遍历全部 O(1)</strong>。一种实现方式使用 <code>unsigned long bSet[]</code>  存储，(由于长整数大小有计算机多少 bit 决定，我们记作 bpL) 对于任意数 k，它存在第 <code>k/bpL - 1</code> 个元素的第 <code>k%bpL</code> 位。<u>对 k 进行操作要用掩码 mask</u>：<code>return unsigned long(1) &lt;&lt; k%bpL</code> ⚠️因为位运算<strong>从右往左</strong>，1 等价于 000&hellip;01，所以是左移。取 k <code>bSet[k/bpL] &amp; mask</code>；删 k <code>bSet[k/bpL] &amp;= ~mask</code>。</p>
</br>
</li>
<li>
<p><strong>树 Tree</strong> 没有 cycle 或 loop (满足 |V|-1=|E|)  的简单<u>有向且单向</u>的平面图</p>
<p>Root：没有父节点；leaf：没有子树；path：图中可行的通路；distance：路径上<u>经过的边数</u>；height：到最远叶子的距离 (<u>空树高为 <strong>-1</strong></u>)；depth：到根的距离。BT：每个节点最多两个子树。Full BT：每个节点都有 0 或 2 个子节点的 BT；Complete BT：最后一层靠左排列其余层全满的 BT(<u>Heap 就是一种 CBT</u>)。</p>
<p>函数 &ldquo;order&rdquo; 中，<code>cout &lt;&lt; p-&gt;data &lt;&lt;'\n';</code> 和 <code>order (p-&gt;left);</code> 和 <code>order(p-&gt;right);</code> 依次对应 &ldquo;根&rdquo;、&ldquo;左&rdquo;、&ldquo;右&rdquo;，以三种顺序排列这三个语句就形成了<strong>二叉树</strong>中的 preorder、 inorder 和 postorder。</p>
<p>⚠️对于 N 个节点，高为 h 的二叉树：节点最多 N ≤ 1x2x4x&hellip;2<sup>h </sup>= <strong>2<sup>h+1</sup>-1</strong>，所以<strong>N∈[h+1, 2<sup>h+1</sup>-1]，反过来可以求出 h 的下限，h∈[⌈log<sub>2</sub>(N+1) - 1⌉, N-1]。</strong></p>
</br>
</li>
<li>
<p><strong>BST 二叉搜索树</strong> 满足对任意有左右子节点的节点 x， <code>x-&gt;left-&gt;data &lt; x-&gt;data; x-&gt;right-&gt;data &lt; x-&gt;data;</code> 的不重复的二叉树，<u>其 inorder 是严格升序的</u>。除遍历平均 O(logn)，退化为链表则全部 O(n)。</p>
<p>接口：find()、findMin()、findMax()、insert()、remove()</p>
<p>寻找 v 的函数从某处 x 开始递归，比右大就 <code>find(x-&gt;right)</code> 比左小就 <code>find(x-&gt;left)</code> 都不满足就比较 x 和 v，相等就返回其指针，不相等返回 nullptr。</p>
<p>找最小项只需 从某处 x 开始一路往左递归到底 <code>if(!x-&gt;left) {return x;} return findMin(x-&gt;left);</code> 即可；找最大项则两处方向相反。</p>
<p>插入 v 的函数 (不插重复值) 先类似于 find v，会遍历到某节点的左/右子节点是一个空节点，此时 new 一个叶节点即可。</p>
<p>删除 v 的函数同样先 find v，找到 x 节点，如果 <code>if(x-&gt;left &amp;&amp; x-&gt;right) {}</code> 有两个孩子，<code>x-&gt;data = findMin(x-&gt;right)-&gt;data; remove(x-&gt;data, x-&gt;right);</code> 就<u>将中序后继值 (或前任值) 代替 x 的值并 递归删掉它</u>，它作为右子树的最大值，必然是一个叶节点，套用一个孩子的情况就可以兼容：<code>else {Node&lt;t&gt;* old = x; x = (x-&gt;left) ? t-&gt;left : t-&gt;right; delete old;}</code> (左有节点就代替当前点，反之用右节点代替，<u>没有节点相当于把当前节点悬空</u>)</p>
</li>
</ul>
</br>
</br>
<ol start="5">
<li><strong>Balanced BST</strong></li>
</ol>
<ul>
<li>
<p>用平衡条件让二叉搜索树不超过 logn 级别的高度，就不会退化。</p>
</li>
<li>
<p><strong>AVL</strong> 要求任意节点的左右子树的高度差不超过 1，<u>故而所有叶节点的深度波动不超出 ±1</u>。这种情况下，随意 insert() 和 delete() 都有大概率破坏平衡。需要在节点类新增一个 height 变量和 height() 函数来记录和返回高度，LminusR() 来记录**<u>平衡系数</u><strong>，如<code>height(n-&gt;left) - height(n-&gt;right)</code> ≤ ±1就正常，小于负一说明右子树过长，就需要</strong>重平衡**。</p>
<p>⚠️插/删<u>会且只会影响当前节点到根的路径上的点的高度和平衡性！</u> 所以除了左右指针，我们还需要 <strong>parent</strong> 指针才能向上找问题。</p>
<p>设想一个 <strong>reBalance</strong> 函数，<strong>在插/删之后原地调用</strong>，先更新当前点的高度，<u>从这点开始往 parent 遍历到根：更新高度并检查每一个点的 LminusR()</u>，出现的 ⚠️<strong>第一个失衡点处</strong>，如果 LminusR(n)&gt;1，说明左树过长，检查 LminusR(n-&gt;left)，≥0 说明属于 <strong>LL</strong> 情况，右旋 n；&lt;0 说明属于 LR 情况 先左旋 n-&gt;left <strong><u>变成 LL</strong> 情况</u>再右旋 n。反之 LminusR(n)&lt;1 也一样分为 <strong>RR</strong> (左旋 n) 和 RL (右旋 n-&gt;right <strong>变成 RR</strong> 再左旋 n) 两种情况。总体逻辑如下：</p>
<pre tabindex="0"><code class="language-pseudocode" data-lang="pseudocode">                                   / &lt;-1(LR): node-&gt;left = lRotate(n-&gt;left);
             / &gt;1:LminsR(n-&gt;left)〈              ↓ ↓ ↓ ↓ ↓(turns into LL)
            /                      \ ≥1(LL): return rRotate(n);
LminusR(n)〈                         / &gt;1(RL): node-&gt;right = rRotate(n-&gt;right);
            \ &lt;-1:LminusR(n-&gt;right)〈               ↓ ↓ ↓ ↓ ↓(turns into RR)
                                     \ ≤-1(RR): return lRotate(n);
</code></pre><ul>
<li>
<p>左旋就是 n 继承<u>右子节点的左子树</u>并成为<u>右子节点的左子树</u> (继承为 n 的右子树)。相当于交换 n 和其右子节点，抬高了右子节点的右子树 (即所谓的 <strong>RR</strong>)</p>
</li>
<li>
<p>右旋就是 n 继承<u>左子节点的右子树</u>并成为<u>左子节点的右子树</u> (继承为 n 的左子树)。相当于交换 n 和其左子节点，抬高了左子节点的左子树 (即所谓的 <strong>LL</strong>)</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> rRotate(Node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">*</span>n) {
</span></span><span style="display:flex;"><span>	Node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">*</span>son <span style="color:#f92672">=</span> n<span style="color:#f92672">-&gt;</span>left, <span style="color:#f92672">*</span>rsT <span style="color:#f92672">=</span> son<span style="color:#f92672">-&gt;</span>right; 
</span></span><span style="display:flex;"><span>	son<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> n;
</span></span><span style="display:flex;"><span>	n<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> rsT; 
</span></span><span style="display:flex;"><span>	n<span style="color:#f92672">-&gt;</span>height <span style="color:#f92672">=</span> height(n); son<span style="color:#f92672">-&gt;</span>height <span style="color:#f92672">=</span> height(son);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> son;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>左右旋以及为何分一到两次旋转的意义不言而喻。</p>
</br>
</li>
<li>
<p><strong>RBTree 红黑树</strong> 是 Stanford 研发的另一种平衡方式，目的相同，利用 <code>enum COLOR {RED, BLACK};</code>，<u><strong>所有新增节点初始化为红色</strong></u>。</p>
<p>注意⚠️：红黑树中<u><strong>黑与空是等价的</strong></u>。红黑树中所谓的叶节点的概念与上文完全不同，现在<u>叶代表 <strong>NIL</strong></u><strong>(空占位节点)</strong>——任意节点如果没有左或右子节点就伸出 NIL，因为 <u><strong>黑 ≡ 空</strong>，<strong>NIL 都是黑的</strong></u>。</p>
<p>红黑树的<strong>五大性质</strong>：<strong>node color</strong>: 所有节点非黑即红；<strong>root property</strong>：根永远黑；<strong>leaf property</strong>: 所有 NIL 都黑；<strong>red property</strong>: 不存在互为父子的红色节点；<strong>black property</strong>: 从任意节点到所有 NIL 的路径中经过的黑节点数量相等，称为 <u><strong>bh</strong> (black height)</u>。</p>
<p>⚠️对于 N 个节点，高为 h 的红黑树：高度至少为 bh，所以N∈[<strong>2<sup>bh</sup>-1</strong>, 2<sup>h+1</sup>-1]，又因为 <strong>h ≤ 2 bh</strong>(最高也只能红黑相间)，可以得到 h∈[⌈log<sub>2</sub>(N+1) - 1⌉, <strong>⌊2log<sub>2</sub>(N+1) - 1⌋</strong>]。很明显，相比二叉树，红黑树高度是有上限的，<u><strong>高度最多大约是 AVL 的 2 倍</strong></u>，无法退化到链表。</p>
<p>红黑树也有一套类似 AVL 的重平衡机制，以下对于<strong>插入</strong>一个节点 node：</p>
<pre tabindex="0"><code class="language-pseudocode" data-lang="pseudocode">       / parent B/NIL：保证根 B，结束。
node 〈             / 叔 R：叔、父、祖父，颜色反转；并将祖父作为 node 递归；
       \ parent R 〈
                    \ 叔 B/NIL：回溯 node 的父、祖父：LR/RL双旋换色(后一次)；LL/RR单旋换色。
</code></pre><p>父亲黑时没有问题，但<u>如果这过节点本身是根，那就需要把它染黑</u>来保证 black property。</p>
<p>父亲红时必然会违反 red property，我们需要分的<strong>大情况</strong>是 &ldquo;父亲是祖父的哪个孩子？&rdquo; 在此之下讨论 uncle 的两种情况。</p>
<ul>
<li>其中 <strong>&ldquo;父红叔黑&rdquo;</strong> 的部分几乎与 AVL 是一样的，区别是**<u>不需要往上找失衡点</u>**，直接原地讨论：</li>
</ul>
<pre tabindex="0"><code class="language-pseudocode" data-lang="pseudocode">(Node&lt;T&gt;* gp  = node-&gt;parent-&gt;parent; Node&lt;T&gt;* p = node-&gt;parent;)                      
                                / 右子(LR): p = lRotate(p);
            / 左子，node 是 p 的〈            ↓ ↓ ↓ (turns into LL)
           /                    \ 左子(LL): rRotate(gp); 并换色
p 是 gp 的〈                    / 左子(RL): p = rRotate(p);
           \ 右子，node 是 p 的〈            ↓ ↓ ↓(turns into RR)
                               \ 右子(RR): lRotate(gp); 并换色
</code></pre><ul>
<li>另外一种 <strong>&ldquo;父红叔红&rdquo;</strong> 的部分，直接涂黑两者，把祖父涂红，这样问题就转嫁到祖父身上，将祖父作为 node 递归，<u>我们总会遇到其它两种可解决的情况</u> (比如一路到节点，就属于 &ldquo;父黑&rdquo; 情况)</li>
</ul>
<p>删除的重平衡不完全相同，主要是 <strong>&ldquo;double black&rdquo;</strong> 思路。</p>
<ul>
<li>
<p><strong>删红无所谓</strong>，如果删了黑节点，就会造成路径上黑节点缺少 1：用“这个位置是 double black”来表示；然后根据“兄弟节点的颜色、兄弟孩子的颜色”分类讨论</p>
</li>
<li>
<p>兄弟为红：旋转父亲，<strong>交换父亲(B)和兄弟(R)</strong>，并把兄弟涂黑、父亲涂红。因为交换后的新兄弟节点是原本兄弟(R) 的子节点，一定黑或空，进入情况 (2)。</p>
</li>
<li>
<p>兄弟为黑：兄弟孩子全黑或空：兄弟涂红，把 double black 上移；兄弟存在红孩子：类似于插入，根据这个红侄子与其父、祖父的关系的L/R 关系，旋转 1～2 次并调整颜色。</p>
</li>
</ul>
</li>
</ul>
</br>
</br>
<ol start="6">
<li><strong>Heap</strong></li>
</ol>
<ul>
<li>
<p>堆是 “<strong>按优先级处理</strong>元素” 的数据结构，所以又叫 <strong>Priority Queue</strong>。堆不同于 BST，<u>它不把所有元素整体排序</u>，但堆可以用 BST 实现。分为 MinHeap 和 MaxHeap，优先处理最小或最大项。依旧需要 left, right, parent (<strong>索引</strong>)，接口：insert()、push()、deleteMin() / deleteMax()。</p>
</li>
<li>
<p>建立在 vector 基础上的<u>二叉堆 <strong>Binary Heap</strong> 是最优解</u>，<strong>插/删 O(log N)</strong>，findMin O(1)。二叉堆<u>必须表现为一棵<strong>完全二叉树</strong></u>，并用动态数组形式存储 (⚠️<u>不需要指针！</u>)，二叉堆有两条性质：</p>
<p><strong>结构性</strong>：对于任意索引 i (⚠️<u>存储在 vector 中，所以索引从 0 开始</u>)，其父子节点可以直接计算：<strong>parent(i) = (i−1)/2；left(i) = 2i+1；right(i) = 2i+2</strong>，这样把二叉堆画成 二叉树后<u>索引从左到右从上到下逐行增大，且为<strong>0～N</strong> 的连续整数表示</u>。</p>
<p><strong>有序性 (heap-order property)</strong>：对 MinHeap，所有父节点小于子节点，MaxHeap 反之。堆<u><strong>只保证 “父子有序”</strong></u>，左右是无序的，故中序遍历不会得到升/降序列。</p>
<p>⚠️一棵高 h 的完全二叉树：<strong>N∈[2<sup>h</sup>, 2<sup>h+1</sup>-1]</strong></p>
<p>插入 v：先加入动态数组尾部 <code>minH.push_back(v)</code> 然后<strong>上滤 (siftUp)</strong>： <code>std::swap(minHeap[idx], minHeap[parent(idx)]); idx = parent(idx);</code> 也就是向 parent 方向反复交换直到 parent 小于自己。</p>
<p>删除根 (deleteMin)：<u>先用数组尾项代替根</u> <code>minH[0] = minHeap.pop_back();</code> 然后<strong>下滤 (siftDown)</strong>：循环<strong>交换自己与左右孩子中较小的那个</strong>，直到左右孩子都比自己大。⚠️注意：<u>每次交换先要确定左右孩子存在 <code>left(idx) &lt; size()</code> 防止<strong>下标越界</strong></u>。</p>
<p><strong>buildHeap 建堆</strong>：先将元素写入动态数组 <code>for (int i = 0; i &lt; vec.size(); i++)  {data_.push_back(vec[i]);}</code>，然后从最后一个非叶节点开始下滤 <code>for (int i = size() / 2 - 1; i &gt;= 0; --i) {siftDown(i)}</code> (数组末尾在 N-1，其父节点就在 N/2-1)。总共大约在<strong>O(N)</strong>。</p>
</li>
</ul>
</br>
</br>
<ol start="7">
<li>Graph</li>
</ol>
<ul>
<li>
<p>树是没有循环的图，图是一种满足度数和为偶数的 G~(E, V) 结构。</p>
<p>无向图有边的两点互成邻接，<u>有向图 (digraph) 被指向的点邻接指向它的点</u>。</p>
<p>实现图可以用 <strong>adjacency list</strong>：每个顶点做一个数组/链表，再把顶点做成桶数组 (Map)，<u>遍历复杂度 O(|V|+|E|)</u>；也可以用 <strong>adjacnecy matrix</strong>：用 |V|x|V| 的二维数组 <code>[i][j]</code> 表示 i 到 j 有边，无向图是对角对称的，<u>遍历复杂度 O(|V|<sup>2</sup>)</u>。</p>
<p>DFS：用 stack/递归 先走一条路径到底，然后回溯访问其他路径。思路类似于没有左右的 <strong>preorder</strong></p>
<p>BFS：用 queue 依次走距离近到远的点。</p>
<p>最短路径问题：无权时用 BFS 遍历记下到根的层数；有权需要用 <u><strong>Dijkstra 算法</strong></u>：从 r 开始，对当前点所有相邻点，如果<strong>当前点到 r 的距离+边权重</strong>比记录值更小，就更新距离，如此多轮。</p>
<p>Tropological Sorting： <u>对 <strong>DAG</strong> (有权无环图)</u>，如果 (u, v) 有边，先访问 u (先访问所有前序点)。</p>
</li>
</ul>
<ul class="pa0">
  
   <li class="list di">
     <a href="http://localhost:1313/tags/csc3200/" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">CSC3200</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
        
          <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "nero-lithos" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        
      </div>
    </div>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3"></p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="http://localhost:1313/posts/3200.f2/">💻 CSC3200 Final Revision C&#43;&#43; 数据结构(非线性)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="http://localhost:1313/posts/3200.f1/">💻 CSC3200 Final Revision C&#43;&#43; 数据结构(线性)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="http://localhost:1313/posts/3200.2/">💻 CSC3200 LEC3-5 C&#43;&#43;进阶</a>
        </li>
	    
	     <li  class="mb2">
          <a href="http://localhost:1313/posts/3200.1/">💻 CSC3200 LEC1-2 C&#43;&#43;入门</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="custom-footer">
  <p>&copy; Lithos&#39; Blog 2026</p>

  
    <ul class="footer-links">
      
        <li><a href="https://github.com/Nerolithos" target="_blank" rel="noopener noreferrer">💻 GitHub</a></li>
      
        <li><a href="https://www.pixiv.net/users/107379421" target="_blank" rel="noopener noreferrer">🎨 Pixiv</a></li>
      
        <li><a href="https://blog.nero-lithos.com/" target="_blank" rel="noopener noreferrer">🏠 Home</a></li>
      
        <li><a href="https://futuregate.streamlit.app/" target="_blank" rel="noopener noreferrer">🤖 CUHKSZ AI</a></li>
      
    </ul>
  
</footer>

  </body>
</html>